/**
 * API Rate Limiting Utilities
 * 
 * Rate limiting implementation for NAMC API endpoints:
 * - Configurable rate limits per endpoint
 * - Multiple rate limiting strategies
 * - Redis-backed persistence (with fallback)
 * - IP-based and user-based limiting
 * - Burst protection and sliding windows
 */

import { NextRequest } from 'next/server'
import { ApiError } from './response'

interface RateLimitConfig {
  limit: number // Maximum requests
  windowMs: number // Time window in milliseconds
  keyGenerator?: (request: NextRequest) => string // Custom key generation
  skipFailedRequests?: boolean // Don't count failed requests
  skipSuccessfulRequests?: boolean // Don't count successful requests
  strategy?: 'fixed-window' | 'sliding-window' | 'token-bucket'
}

interface RateLimitInfo {
  totalRequests: number
  remainingRequests: number
  resetTime: number
  isLimited: boolean
}

// In-memory store (use Redis in production)
const rateLimitStore = new Map<string, {
  requests: number[]
  tokens?: number
  lastRefill?: number
}>()

/**
 * Main rate limiting function
 */
export async function rateLimit(
  request: NextRequest,
  config: RateLimitConfig
): Promise<RateLimitInfo> {
  const {
    limit,
    windowMs,
    keyGenerator = defaultKeyGenerator,
    strategy = 'sliding-window'
  } = config

  const key = keyGenerator(request)
  const now = Date.now()

  let rateLimitInfo: RateLimitInfo

  switch (strategy) {
    case 'fixed-window':
      rateLimitInfo = await fixedWindowRateLimit(key, limit, windowMs, now)
      break
    case 'sliding-window':
      rateLimitInfo = await slidingWindowRateLimit(key, limit, windowMs, now)
      break
    case 'token-bucket':
      rateLimitInfo = await tokenBucketRateLimit(key, limit, windowMs, now)
      break
    default:
      throw new Error(`Unknown rate limiting strategy: ${strategy}`)
  }

  if (rateLimitInfo.isLimited) {
    throw new ApiError(
      'Rate limit exceeded',
      429,
      'RATE_LIMIT_EXCEEDED',
      {
        limit,
        remaining: rateLimitInfo.remainingRequests,
        resetTime: rateLimitInfo.resetTime,
        retryAfter: Math.ceil((rateLimitInfo.resetTime - now) / 1000)
      }
    )
  }

  return rateLimitInfo
}

/**
 * Fixed window rate limiting
 */
async function fixedWindowRateLimit(
  key: string,
  limit: number,
  windowMs: number,
  now: number
): Promise<RateLimitInfo> {
  const windowStart = Math.floor(now / windowMs) * windowMs
  const windowKey = `${key}:${windowStart}`

  let entry = rateLimitStore.get(windowKey)
  if (!entry) {
    entry = { requests: [] }
    rateLimitStore.set(windowKey, entry)
  }

  const currentRequests = entry.requests.length
  const isLimited = currentRequests >= limit

  if (!isLimited) {
    entry.requests.push(now)
  }

  // Clean up old windows
  cleanupOldEntries(windowMs)

  return {
    totalRequests: currentRequests + (isLimited ? 0 : 1),
    remainingRequests: Math.max(0, limit - currentRequests - (isLimited ? 0 : 1)),
    resetTime: windowStart + windowMs,
    isLimited
  }
}

/**
 * Sliding window rate limiting
 */
async function slidingWindowRateLimit(
  key: string,
  limit: number,
  windowMs: number,
  now: number
): Promise<RateLimitInfo> {
  let entry = rateLimitStore.get(key)
  if (!entry) {
    entry = { requests: [] }
    rateLimitStore.set(key, entry)
  }

  // Remove requests outside the current window
  const windowStart = now - windowMs
  entry.requests = entry.requests.filter(timestamp => timestamp > windowStart)

  const currentRequests = entry.requests.length
  const isLimited = currentRequests >= limit

  if (!isLimited) {
    entry.requests.push(now)
  }

  // Clean up old entries periodically
  if (Math.random() < 0.01) { // 1% chance
    cleanupOldEntries(windowMs)
  }

  return {
    totalRequests: currentRequests + (isLimited ? 0 : 1),
    remainingRequests: Math.max(0, limit - currentRequests - (isLimited ? 0 : 1)),
    resetTime: now + windowMs,
    isLimited
  }
}

/**
 * Token bucket rate limiting
 */
async function tokenBucketRateLimit(
  key: string,
  limit: number,
  windowMs: number,
  now: number
): Promise<RateLimitInfo> {
  let entry = rateLimitStore.get(key)
  if (!entry) {
    entry = { 
      requests: [],
      tokens: limit,
      lastRefill: now
    }
    rateLimitStore.set(key, entry)
  }

  // Refill tokens based on time elapsed
  const refillRate = limit / windowMs // tokens per millisecond
  const timeSinceLastRefill = now - (entry.lastRefill || now)
  const tokensToAdd = Math.floor(timeSinceLastRefill * refillRate)

  entry.tokens = Math.min(limit, (entry.tokens || 0) + tokensToAdd)
  entry.lastRefill = now

  const isLimited = (entry.tokens || 0) < 1

  if (!isLimited) {
    entry.tokens = (entry.tokens || 0) - 1
    entry.requests.push(now)
  }

  return {
    totalRequests: entry.requests.length,
    remainingRequests: Math.floor(entry.tokens || 0),
    resetTime: now + Math.ceil((1 - (entry.tokens || 0) % 1) / refillRate),
    isLimited
  }
}

/**
 * Default key generator (IP-based)
 */
function defaultKeyGenerator(request: NextRequest): string {
  const forwarded = request.headers.get('x-forwarded-for')
  const ip = forwarded ? forwarded.split(',')[0] : 
             request.headers.get('x-real-ip') || 
             request.ip || 
             'unknown'
  
  return `ip:${ip}`
}

/**
 * User-based key generator
 */
export function userKeyGenerator(userId: string): (request: NextRequest) => string {
  return () => `user:${userId}`
}

/**
 * Endpoint-based key generator
 */
export function endpointKeyGenerator(endpoint: string): (request: NextRequest) => string {
  return (request: NextRequest) => {
    const ip = defaultKeyGenerator(request)
    return `${endpoint}:${ip}`
  }
}

/**
 * Combined key generator (IP + User)
 */
export function combinedKeyGenerator(userId?: string): (request: NextRequest) => string {
  return (request: NextRequest) => {
    const ip = defaultKeyGenerator(request)
    return userId ? `combined:${userId}:${ip}` : ip
  }
}

/**
 * Predefined rate limit configurations
 */
export const RateLimitConfigs = {
  // Very strict for sensitive operations
  strict: {
    limit: 5,
    windowMs: 60 * 1000, // 1 minute
    strategy: 'sliding-window' as const
  },

  // Standard for most API endpoints
  standard: {
    limit: 100,
    windowMs: 60 * 1000, // 1 minute
    strategy: 'sliding-window' as const
  },

  // Relaxed for read-only operations
  relaxed: {
    limit: 1000,
    windowMs: 60 * 1000, // 1 minute
    strategy: 'sliding-window' as const
  },

  // For authentication attempts
  auth: {
    limit: 5,
    windowMs: 15 * 60 * 1000, // 15 minutes
    strategy: 'fixed-window' as const
  },

  // For file uploads
  upload: {
    limit: 10,
    windowMs: 60 * 1000, // 1 minute
    strategy: 'token-bucket' as const
  },

  // For HubSpot sync operations
  hubspotSync: {
    limit: 20,
    windowMs: 60 * 1000, // 1 minute
    strategy: 'token-bucket' as const
  },

  // For workflow executions
  workflowExecution: {
    limit: 50,
    windowMs: 60 * 1000, // 1 minute
    strategy: 'sliding-window' as const
  },

  // For analytics queries
  analytics: {
    limit: 30,
    windowMs: 60 * 1000, // 1 minute
    strategy: 'sliding-window' as const
  }
}

/**
 * Per-endpoint rate limiting configurations
 */
export const EndpointRateLimits = {
  // Authentication endpoints
  'POST /api/auth/login': RateLimitConfigs.auth,
  'POST /api/auth/register': RateLimitConfigs.auth,
  'POST /api/auth/forgot-password': RateLimitConfigs.auth,
  'POST /api/auth/reset-password': RateLimitConfigs.auth,

  // HubSpot workflow endpoints
  'GET /api/hubspot/workflows': RateLimitConfigs.standard,
  'POST /api/hubspot/workflows': {
    limit: 20,
    windowMs: 60 * 1000,
    strategy: 'sliding-window' as const
  },
  'PUT /api/hubspot/workflows': {
    limit: 30,
    windowMs: 60 * 1000,
    strategy: 'sliding-window' as const
  },
  'DELETE /api/hubspot/workflows': RateLimitConfigs.strict,

  // Workflow execution endpoints
  'POST /api/hubspot/workflows/*/executions': RateLimitConfigs.workflowExecution,
  'GET /api/hubspot/workflows/*/executions': RateLimitConfigs.standard,

  // Analytics endpoints
  'GET /api/hubspot/analytics': RateLimitConfigs.analytics,
  'POST /api/hubspot/analytics/compare': RateLimitConfigs.analytics,

  // Sync endpoints
  'GET /api/hubspot/sync': RateLimitConfigs.standard,
  'POST /api/hubspot/sync': RateLimitConfigs.hubspotSync,

  // Member endpoints
  'GET /api/members': RateLimitConfigs.relaxed,
  'POST /api/members': RateLimitConfigs.standard,
  'PUT /api/members': RateLimitConfigs.standard,

  // Upload endpoints
  'POST /api/upload': RateLimitConfigs.upload
}

/**
 * Get rate limit configuration for endpoint
 */
export function getRateLimitConfig(
  method: string,
  pathname: string
): RateLimitConfig {
  const endpointKey = `${method} ${pathname}`
  
  // Check for exact match
  if (EndpointRateLimits[endpointKey]) {
    return EndpointRateLimits[endpointKey]
  }

  // Check for wildcard matches
  for (const [pattern, config] of Object.entries(EndpointRateLimits)) {
    if (pattern.includes('*')) {
      const regex = new RegExp(pattern.replace(/\*/g, '[^/]+'))
      if (regex.test(endpointKey)) {
        return config
      }
    }
  }

  // Default to standard rate limiting
  return RateLimitConfigs.standard
}

/**
 * Clean up old entries from rate limit store
 */
function cleanupOldEntries(windowMs: number): void {
  const now = Date.now()
  const cutoff = now - windowMs * 2 // Keep some buffer

  for (const [key, entry] of rateLimitStore.entries()) {
    if (entry.requests.length === 0 || 
        Math.max(...entry.requests) < cutoff) {
      rateLimitStore.delete(key)
    }
  }

  // Limit store size
  if (rateLimitStore.size > 10000) {
    const keysToDelete = Array.from(rateLimitStore.keys()).slice(0, 1000)
    keysToDelete.forEach(key => rateLimitStore.delete(key))
  }
}

/**
 * Reset rate limit for a specific key (admin function)
 */
export function resetRateLimit(key: string): boolean {
  return rateLimitStore.delete(key)
}

/**
 * Get current rate limit status without incrementing
 */
export function getRateLimitStatus(
  request: NextRequest,
  config: RateLimitConfig
): RateLimitInfo {
  const { limit, windowMs, keyGenerator = defaultKeyGenerator } = config
  const key = keyGenerator(request)
  const now = Date.now()

  const entry = rateLimitStore.get(key)
  if (!entry) {
    return {
      totalRequests: 0,
      remainingRequests: limit,
      resetTime: now + windowMs,
      isLimited: false
    }
  }

  // Calculate based on strategy (simplified for status check)
  const windowStart = now - windowMs
  const validRequests = entry.requests.filter(timestamp => timestamp > windowStart)

  return {
    totalRequests: validRequests.length,
    remainingRequests: Math.max(0, limit - validRequests.length),
    resetTime: now + windowMs,
    isLimited: validRequests.length >= limit
  }
}

/**
 * Middleware wrapper for easy integration
 */
export function withRateLimit(config: RateLimitConfig) {
  return async (request: NextRequest): Promise<RateLimitInfo> => {
    return await rateLimit(request, config)
  }
}